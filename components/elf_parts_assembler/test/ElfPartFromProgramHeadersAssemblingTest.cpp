#include <gtest/gtest.h>
#include <gmock/gmock.h>
#include "ElfPartTestingUtility.hpp"
#include "ElfPartAssembler.hpp"
#include "ElfPart.hpp"
#include <cstdint>
#include <elf.h>
#include <QString>
#include "ElfPart.hpp"
#include <vector>


namespace
{
    constexpr uint32_t FLAG_EXECUTABLE_SEGMENT { 0x1 };
    constexpr uint32_t FLAG_WRITABLE_SEGMENT { 0x2 };
    constexpr uint32_t FLAG_READABLE_SEGMENT { 0x4 };

    //first
    constexpr uint32_t FIRST_PROGRAM_HEADER_TYPE_VALUE { 3 };
    const QString FIRST_PROGRAM_HEADER_TYPE_VALUE_TEXT { "3" };
    const QString FIRST_PROGRAM_HEADER_TYPE_DESCRIPTION_TEXT { "Segment type: Program interpreter" };

    constexpr uint64_t FIRST_PROGRAM_HEADER_OFFSET_VALUE { 0x318 };
    const QString FIRST_PROGRAM_HEADER_OFFSET_VALUE_TEXT { "0x318" };
    const QString FIRST_PROGRAM_HEADER_OFFSET_DESCRIPTION_TEXT { "Segment offset in the file: 0x318" };

    constexpr uint64_t FIRST_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE { 0x318 };
    const QString FIRST_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE_TEXT { "0x318" };
    const QString FIRST_PROGRAM_HEADER_VIRTUAL_ADDRESS_DESCRIPTION_TEXT { "Virtual address of the segment in the memory: 0x318" };

    constexpr uint64_t FIRST_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE { 0x318 };
    const QString FIRST_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE_TEXT { "0x318" };
    const QString FIRST_PROGRAM_HEADER_PHYSICAL_ADDRESS_DESCRIPTION_TEXT { "Physical address of the segment: 0x318" };

    constexpr uint64_t FIRST_PROGRAM_HEADER_FILESIZE_VALUE { 24 };
    const QString FIRST_PROGRAM_HEADER_FILESIZE_VALUE_TEXT { "24" };
    const QString FIRST_PROGRAM_HEADER_FILESIZE_DESCRIPTION_TEXT { "Size of the segment in the file: 24 bytes" };

    constexpr uint64_t FIRST_PROGRAM_HEADER_MEMSIZE_VALUE { 24 };
    const QString FIRST_PROGRAM_HEADER_MEMSIZE_VALUE_TEXT { "24" };
    const QString FIRST_PROGRAM_HEADER_MEMSIZE_DESCRIPTION_TEXT { "Size of the segment in the memory: 24 bytes" };

    constexpr uint32_t FIRST_PROGRAM_HEADER_FLAGS_VALUE { FLAG_READABLE_SEGMENT };
    const QString FIRST_PROGRAM_HEADER_FLAGS_VALUE_TEXT { "0x4" };
    const QString FIRST_PROGRAM_HEADER_FLAGS_DESCRIPTION_TEXT { "0x4 Readable" };

    constexpr uint64_t FIRST_PROGRAM_HEADER_ALIGN_VALUE { 1 };
    const QString FIRST_PROGRAM_HEADER_ALIGN_VALUE_TEXT { "1" };
    const QString FIRST_PROGRAM_HEADER_ALIGN_DESCRIPTION_TEXT { "Address align: 1 bytes" };

    // second
    constexpr uint32_t SECOND_PROGRAM_HEADER_TYPE_VALUE { 1 };
    const QString SECOND_PROGRAM_HEADER_TYPE_VALUE_TEXT { "1" };
    const QString SECOND_PROGRAM_HEADER_TYPE_DESCRIPTION_TEXT { "Segment type: Loadable program segment" };

    constexpr Elf32_Off SECOND_PROGRAM_HEADER_OFFSET_VALUE { 0x1000 };
    const QString SECOND_PROGRAM_HEADER_OFFSET_VALUE_TEXT { "0x1000" };
    const QString SECOND_PROGRAM_HEADER_OFFSET_DESCRIPTION_TEXT { "Segment offset in the file: 0x1000" };

    constexpr Elf32_Addr SECOND_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE { 0x1000 };
    const QString SECOND_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE_TEXT { "0x1000" };
    const QString SECOND_PROGRAM_HEADER_VIRTUAL_ADDRESS_DESCRIPTION_TEXT { "Virtual address of the segment in the memory: 0x1000" };

    constexpr Elf32_Addr SECOND_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE { 0x1000 };
    const QString SECOND_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE_TEXT { "0x1000" };
    const QString SECOND_PROGRAM_HEADER_PHYSICAL_ADDRESS_DESCRIPTION_TEXT { "Physical address of the segment: 0x1000" };

    constexpr Elf32_Word SECOND_PROGRAM_HEADER_FILESIZE_VALUE { 557 };
    const QString SECOND_PROGRAM_HEADER_FILESIZE_VALUE_TEXT { "557" };
    const QString SECOND_PROGRAM_HEADER_FILESIZE_DESCRIPTION_TEXT { "Size of the segment in the file: 557 bytes" };

    constexpr Elf32_Word SECOND_PROGRAM_HEADER_MEMSIZE_VALUE { 557 };
    const QString SECOND_PROGRAM_HEADER_MEMSIZE_VALUE_TEXT { "557" };
    const QString SECOND_PROGRAM_HEADER_MEMSIZE_DESCRIPTION_TEXT { "Size of the segment in the memory: 557 bytes" };

    constexpr uint32_t SECOND_PROGRAM_HEADER_FLAGS_VALUE { FLAG_READABLE_SEGMENT | FLAG_EXECUTABLE_SEGMENT };
    const QString SECOND_PROGRAM_HEADER_FLAGS_VALUE_TEXT { "0x5" };
    const QString SECOND_PROGRAM_HEADER_FLAGS_DESCRIPTION_TEXT { "0x1 Executable\n0x4 Readable" };

    constexpr Elf32_Word SECOND_PROGRAM_HEADER_ALIGN_VALUE { 4096 };
    const QString SECOND_PROGRAM_HEADER_ALIGN_VALUE_TEXT { "4096" };
    const QString SECOND_PROGRAM_HEADER_ALIGN_DESCRIPTION_TEXT { "Address align: 4096 bytes" };

    // third
    constexpr uint32_t THIRD_PROGRAM_HEADER_TYPE_VALUE { 2 };
    const QString THIRD_PROGRAM_HEADER_TYPE_VALUE_TEXT { "2" };
    const QString THIRD_PROGRAM_HEADER_TYPE_DESCRIPTION_TEXT { "Segment type: Dynamic linking information" };

    constexpr Elf32_Off THIRD_PROGRAM_HEADER_OFFSET_VALUE { 0x2da0 };
    const QString THIRD_PROGRAM_HEADER_OFFSET_VALUE_TEXT { "0x2DA0" };
    const QString THIRD_PROGRAM_HEADER_OFFSET_DESCRIPTION_TEXT { "Segment offset in the file: 0x2DA0" };

    constexpr Elf32_Addr THIRD_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE { 0x3da0 };
    const QString THIRD_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE_TEXT { "0x3DA0" };
    const QString THIRD_PROGRAM_HEADER_VIRTUAL_ADDRESS_DESCRIPTION_TEXT { "Virtual address of the segment in the memory: 0x3DA0" };

    constexpr Elf32_Addr THIRD_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE { 0x3da0 };
    const QString THIRD_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE_TEXT { "0x3DA0" };
    const QString THIRD_PROGRAM_HEADER_PHYSICAL_ADDRESS_DESCRIPTION_TEXT { "Physical address of the segment: 0x3DA0" };

    constexpr Elf32_Word THIRD_PROGRAM_HEADER_FILESIZE_VALUE { 512 };
    const QString THIRD_PROGRAM_HEADER_FILESIZE_VALUE_TEXT { "512" };
    const QString THIRD_PROGRAM_HEADER_FILESIZE_DESCRIPTION_TEXT { "Size of the segment in the file: 512 bytes" };

    constexpr Elf32_Word THIRD_PROGRAM_HEADER_MEMSIZE_VALUE { 512 };
    const QString THIRD_PROGRAM_HEADER_MEMSIZE_VALUE_TEXT { "512" };
    const QString THIRD_PROGRAM_HEADER_MEMSIZE_DESCRIPTION_TEXT { "Size of the segment in the memory: 512 bytes" };

    constexpr uint32_t THIRD_PROGRAM_HEADER_FLAGS_VALUE { FLAG_READABLE_SEGMENT | FLAG_WRITABLE_SEGMENT };
    const QString THIRD_PROGRAM_HEADER_FLAGS_VALUE_TEXT { "0x6" };
    const QString THIRD_PROGRAM_HEADER_FLAGS_DESCRIPTION_TEXT { "0x2 Writeable\n0x4 Readable" };

    constexpr Elf32_Word THIRD_PROGRAM_HEADER_ALIGN_VALUE { 8 };
    const QString THIRD_PROGRAM_HEADER_ALIGN_VALUE_TEXT { "8" };
    const QString THIRD_PROGRAM_HEADER_ALIGN_DESCRIPTION_TEXT { "Address align: 8 bytes" };


    const QString P_TYPE_NAME_TEXT { "p_type" };
    const QString P_OFFSET_NAME_TEXT { "p_offset" };
    const QString P_VADDR_NAME_TEXT { "p_vaddr" };
    const QString P_PADDR_NAME_TEXT { "p_paddr" };
    const QString P_FILESZ_NAME_TEXT { "p_filesz" };
    const QString P_MEMSZ_NAME_TEXT { "p_memsz" };
    const QString P_FLAGS_NAME_TEXT { "p_flags" };
    const QString P_ALIGN_NAME_TEXT { "p_align" };



    const QString PROGRAM_HEADER_ELF_PART_NAME { "ProgramHeader" };
    const ElfPartType PROGRAM_HEADER_ELF_PART_TYPE { ElfPartType::ProgramHeader };
    constexpr int PROGRAM_HEADER_ELF_PART_OFFSET_32BIT_VALUE { 52 };
    constexpr int PROGRAM_HEADER_ELF_PART_OFFSET_64BIT_VALUE { 64 };
    constexpr int PROGRAM_HEADER_ELF_PART_SIZE_32BIT_VALUE { 32 };
    constexpr int PROGRAM_HEADER_ELF_PART_SIZE_64BIT_VALUE { 56 };
    const QString PROGRAM_HEADER_ELF_PART_DESCRIPTION {
        "Program Header contains information necessary for creating the process image. Each segment of the process image is described by the type, memory access flags, its offset and total size."
    };


    ElfPart generateProgramHeaderElfPart(std::vector<ElfField> p_fields, int p_offset, int p_size)
    {
        return { PROGRAM_HEADER_ELF_PART_NAME, PROGRAM_HEADER_ELF_PART_TYPE, p_offset, p_size, PROGRAM_HEADER_ELF_PART_DESCRIPTION, p_fields };
    }

    std::vector<ElfPart> generate32BitElfParts()
    {
        return {
            generateProgramHeaderElfPart({
                {P_TYPE_NAME_TEXT, ELF32_WORD_TEXT, FIRST_PROGRAM_HEADER_TYPE_VALUE_TEXT, FIRST_PROGRAM_HEADER_TYPE_DESCRIPTION_TEXT},
                {P_OFFSET_NAME_TEXT, ELF32_OFF_TEXT, FIRST_PROGRAM_HEADER_OFFSET_VALUE_TEXT, FIRST_PROGRAM_HEADER_OFFSET_DESCRIPTION_TEXT},
                {P_VADDR_NAME_TEXT, ELF32_ADDR_TEXT, FIRST_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE_TEXT, FIRST_PROGRAM_HEADER_VIRTUAL_ADDRESS_DESCRIPTION_TEXT},
                {P_PADDR_NAME_TEXT, ELF32_ADDR_TEXT, FIRST_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE_TEXT, FIRST_PROGRAM_HEADER_PHYSICAL_ADDRESS_DESCRIPTION_TEXT},
                {P_FILESZ_NAME_TEXT, ELF32_WORD_TEXT, FIRST_PROGRAM_HEADER_FILESIZE_VALUE_TEXT, FIRST_PROGRAM_HEADER_FILESIZE_DESCRIPTION_TEXT},
                {P_MEMSZ_NAME_TEXT, ELF32_WORD_TEXT, FIRST_PROGRAM_HEADER_MEMSIZE_VALUE_TEXT, FIRST_PROGRAM_HEADER_MEMSIZE_DESCRIPTION_TEXT},
                {P_FLAGS_NAME_TEXT, ELF32_WORD_TEXT, FIRST_PROGRAM_HEADER_FLAGS_VALUE_TEXT, FIRST_PROGRAM_HEADER_FLAGS_DESCRIPTION_TEXT},
                {P_ALIGN_NAME_TEXT, ELF32_WORD_TEXT, FIRST_PROGRAM_HEADER_ALIGN_VALUE_TEXT, FIRST_PROGRAM_HEADER_ALIGN_DESCRIPTION_TEXT}
            }, PROGRAM_HEADER_ELF_PART_OFFSET_32BIT_VALUE, PROGRAM_HEADER_ELF_PART_SIZE_32BIT_VALUE),
            generateProgramHeaderElfPart({
                {P_TYPE_NAME_TEXT, ELF32_WORD_TEXT, SECOND_PROGRAM_HEADER_TYPE_VALUE_TEXT, SECOND_PROGRAM_HEADER_TYPE_DESCRIPTION_TEXT},
                {P_OFFSET_NAME_TEXT, ELF32_OFF_TEXT, SECOND_PROGRAM_HEADER_OFFSET_VALUE_TEXT, SECOND_PROGRAM_HEADER_OFFSET_DESCRIPTION_TEXT},
                {P_VADDR_NAME_TEXT, ELF32_ADDR_TEXT, SECOND_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE_TEXT, SECOND_PROGRAM_HEADER_VIRTUAL_ADDRESS_DESCRIPTION_TEXT},
                {P_PADDR_NAME_TEXT, ELF32_ADDR_TEXT, SECOND_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE_TEXT, SECOND_PROGRAM_HEADER_PHYSICAL_ADDRESS_DESCRIPTION_TEXT},
                {P_FILESZ_NAME_TEXT, ELF32_WORD_TEXT, SECOND_PROGRAM_HEADER_FILESIZE_VALUE_TEXT, SECOND_PROGRAM_HEADER_FILESIZE_DESCRIPTION_TEXT},
                {P_MEMSZ_NAME_TEXT, ELF32_WORD_TEXT, SECOND_PROGRAM_HEADER_MEMSIZE_VALUE_TEXT, SECOND_PROGRAM_HEADER_MEMSIZE_DESCRIPTION_TEXT},
                {P_FLAGS_NAME_TEXT, ELF32_WORD_TEXT, SECOND_PROGRAM_HEADER_FLAGS_VALUE_TEXT, SECOND_PROGRAM_HEADER_FLAGS_DESCRIPTION_TEXT},
                {P_ALIGN_NAME_TEXT, ELF32_WORD_TEXT, SECOND_PROGRAM_HEADER_ALIGN_VALUE_TEXT, SECOND_PROGRAM_HEADER_ALIGN_DESCRIPTION_TEXT}
            }, PROGRAM_HEADER_ELF_PART_OFFSET_32BIT_VALUE + PROGRAM_HEADER_ELF_PART_SIZE_32BIT_VALUE, PROGRAM_HEADER_ELF_PART_SIZE_32BIT_VALUE),
            generateProgramHeaderElfPart({
                {P_TYPE_NAME_TEXT, ELF32_WORD_TEXT, THIRD_PROGRAM_HEADER_TYPE_VALUE_TEXT, THIRD_PROGRAM_HEADER_TYPE_DESCRIPTION_TEXT},
                {P_OFFSET_NAME_TEXT, ELF32_OFF_TEXT, THIRD_PROGRAM_HEADER_OFFSET_VALUE_TEXT, THIRD_PROGRAM_HEADER_OFFSET_DESCRIPTION_TEXT},
                {P_VADDR_NAME_TEXT, ELF32_ADDR_TEXT, THIRD_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE_TEXT, THIRD_PROGRAM_HEADER_VIRTUAL_ADDRESS_DESCRIPTION_TEXT},
                {P_PADDR_NAME_TEXT, ELF32_ADDR_TEXT, THIRD_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE_TEXT, THIRD_PROGRAM_HEADER_PHYSICAL_ADDRESS_DESCRIPTION_TEXT},
                {P_FILESZ_NAME_TEXT, ELF32_WORD_TEXT, THIRD_PROGRAM_HEADER_FILESIZE_VALUE_TEXT, THIRD_PROGRAM_HEADER_FILESIZE_DESCRIPTION_TEXT},
                {P_MEMSZ_NAME_TEXT, ELF32_WORD_TEXT, THIRD_PROGRAM_HEADER_MEMSIZE_VALUE_TEXT, THIRD_PROGRAM_HEADER_MEMSIZE_DESCRIPTION_TEXT},
                {P_FLAGS_NAME_TEXT, ELF32_WORD_TEXT, THIRD_PROGRAM_HEADER_FLAGS_VALUE_TEXT, THIRD_PROGRAM_HEADER_FLAGS_DESCRIPTION_TEXT},
                {P_ALIGN_NAME_TEXT, ELF32_WORD_TEXT, THIRD_PROGRAM_HEADER_ALIGN_VALUE_TEXT, THIRD_PROGRAM_HEADER_ALIGN_DESCRIPTION_TEXT}
            }, PROGRAM_HEADER_ELF_PART_OFFSET_32BIT_VALUE + 2 * PROGRAM_HEADER_ELF_PART_SIZE_32BIT_VALUE, PROGRAM_HEADER_ELF_PART_SIZE_32BIT_VALUE)};
    }

    std::vector<ElfPart> generate64BitElfParts()
    {
        return {
            generateProgramHeaderElfPart({
                {P_TYPE_NAME_TEXT, ELF64_WORD_TEXT, FIRST_PROGRAM_HEADER_TYPE_VALUE_TEXT, FIRST_PROGRAM_HEADER_TYPE_DESCRIPTION_TEXT},
                {P_FLAGS_NAME_TEXT, ELF64_WORD_TEXT, FIRST_PROGRAM_HEADER_FLAGS_VALUE_TEXT, FIRST_PROGRAM_HEADER_FLAGS_DESCRIPTION_TEXT},
                {P_OFFSET_NAME_TEXT, ELF64_OFF_TEXT, FIRST_PROGRAM_HEADER_OFFSET_VALUE_TEXT, FIRST_PROGRAM_HEADER_OFFSET_DESCRIPTION_TEXT},
                {P_VADDR_NAME_TEXT, ELF64_ADDR_TEXT, FIRST_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE_TEXT, FIRST_PROGRAM_HEADER_VIRTUAL_ADDRESS_DESCRIPTION_TEXT},
                {P_PADDR_NAME_TEXT, ELF64_ADDR_TEXT, FIRST_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE_TEXT, FIRST_PROGRAM_HEADER_PHYSICAL_ADDRESS_DESCRIPTION_TEXT},
                {P_FILESZ_NAME_TEXT, ELF64_XWORD_TEXT, FIRST_PROGRAM_HEADER_FILESIZE_VALUE_TEXT, FIRST_PROGRAM_HEADER_FILESIZE_DESCRIPTION_TEXT},
                {P_MEMSZ_NAME_TEXT, ELF64_XWORD_TEXT, FIRST_PROGRAM_HEADER_MEMSIZE_VALUE_TEXT, FIRST_PROGRAM_HEADER_MEMSIZE_DESCRIPTION_TEXT},
                {P_ALIGN_NAME_TEXT, ELF64_XWORD_TEXT, FIRST_PROGRAM_HEADER_ALIGN_VALUE_TEXT, FIRST_PROGRAM_HEADER_ALIGN_DESCRIPTION_TEXT}
            }, PROGRAM_HEADER_ELF_PART_OFFSET_64BIT_VALUE, PROGRAM_HEADER_ELF_PART_SIZE_64BIT_VALUE),
            generateProgramHeaderElfPart({
                {P_TYPE_NAME_TEXT, ELF64_WORD_TEXT, SECOND_PROGRAM_HEADER_TYPE_VALUE_TEXT, SECOND_PROGRAM_HEADER_TYPE_DESCRIPTION_TEXT},
                {P_FLAGS_NAME_TEXT, ELF64_WORD_TEXT, SECOND_PROGRAM_HEADER_FLAGS_VALUE_TEXT, SECOND_PROGRAM_HEADER_FLAGS_DESCRIPTION_TEXT},
                {P_OFFSET_NAME_TEXT, ELF64_OFF_TEXT, SECOND_PROGRAM_HEADER_OFFSET_VALUE_TEXT, SECOND_PROGRAM_HEADER_OFFSET_DESCRIPTION_TEXT},
                {P_VADDR_NAME_TEXT, ELF64_ADDR_TEXT, SECOND_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE_TEXT, SECOND_PROGRAM_HEADER_VIRTUAL_ADDRESS_DESCRIPTION_TEXT},
                {P_PADDR_NAME_TEXT, ELF64_ADDR_TEXT, SECOND_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE_TEXT, SECOND_PROGRAM_HEADER_PHYSICAL_ADDRESS_DESCRIPTION_TEXT},
                {P_FILESZ_NAME_TEXT, ELF64_XWORD_TEXT, SECOND_PROGRAM_HEADER_FILESIZE_VALUE_TEXT, SECOND_PROGRAM_HEADER_FILESIZE_DESCRIPTION_TEXT},
                {P_MEMSZ_NAME_TEXT, ELF64_XWORD_TEXT, SECOND_PROGRAM_HEADER_MEMSIZE_VALUE_TEXT, SECOND_PROGRAM_HEADER_MEMSIZE_DESCRIPTION_TEXT},
                {P_ALIGN_NAME_TEXT, ELF64_XWORD_TEXT, SECOND_PROGRAM_HEADER_ALIGN_VALUE_TEXT, SECOND_PROGRAM_HEADER_ALIGN_DESCRIPTION_TEXT}
            }, PROGRAM_HEADER_ELF_PART_OFFSET_64BIT_VALUE + PROGRAM_HEADER_ELF_PART_SIZE_64BIT_VALUE, PROGRAM_HEADER_ELF_PART_SIZE_64BIT_VALUE),
            generateProgramHeaderElfPart({
                {P_TYPE_NAME_TEXT, ELF64_WORD_TEXT, THIRD_PROGRAM_HEADER_TYPE_VALUE_TEXT, THIRD_PROGRAM_HEADER_TYPE_DESCRIPTION_TEXT},
                {P_FLAGS_NAME_TEXT, ELF64_WORD_TEXT, THIRD_PROGRAM_HEADER_FLAGS_VALUE_TEXT, THIRD_PROGRAM_HEADER_FLAGS_DESCRIPTION_TEXT},
                {P_OFFSET_NAME_TEXT, ELF64_OFF_TEXT, THIRD_PROGRAM_HEADER_OFFSET_VALUE_TEXT, THIRD_PROGRAM_HEADER_OFFSET_DESCRIPTION_TEXT},
                {P_VADDR_NAME_TEXT, ELF64_ADDR_TEXT, THIRD_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE_TEXT, THIRD_PROGRAM_HEADER_VIRTUAL_ADDRESS_DESCRIPTION_TEXT},
                {P_PADDR_NAME_TEXT, ELF64_ADDR_TEXT, THIRD_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE_TEXT, THIRD_PROGRAM_HEADER_PHYSICAL_ADDRESS_DESCRIPTION_TEXT},
                {P_FILESZ_NAME_TEXT, ELF64_XWORD_TEXT, THIRD_PROGRAM_HEADER_FILESIZE_VALUE_TEXT, THIRD_PROGRAM_HEADER_FILESIZE_DESCRIPTION_TEXT},
                {P_MEMSZ_NAME_TEXT, ELF64_XWORD_TEXT, THIRD_PROGRAM_HEADER_MEMSIZE_VALUE_TEXT, THIRD_PROGRAM_HEADER_MEMSIZE_DESCRIPTION_TEXT},
                {P_ALIGN_NAME_TEXT, ELF64_XWORD_TEXT, THIRD_PROGRAM_HEADER_ALIGN_VALUE_TEXT, THIRD_PROGRAM_HEADER_ALIGN_DESCRIPTION_TEXT}
            }, PROGRAM_HEADER_ELF_PART_OFFSET_64BIT_VALUE + 2 * PROGRAM_HEADER_ELF_PART_SIZE_64BIT_VALUE, PROGRAM_HEADER_ELF_PART_SIZE_64BIT_VALUE)};
    }
}

using namespace ::testing;


struct ElfPartAssemblerProgramHeadersAssemblingX32TestSuite : public ElfPartAssemblingTestSuite
{};

TEST_F(ElfPartAssemblerProgramHeadersAssemblingX32TestSuite, shouldNotAssembleAnyCorrectElfPartFromEmpty32BitProgramHeadersContainer)
{
    ElfPartAssembler l_elfPartAssembler {};
    std::vector<Elf32_Phdr> l_programHeaders;

    const auto& l_targetElfParts { l_elfPartAssembler.assembleElfPartsFromProgramHeaders(l_programHeaders, PROGRAM_HEADER_ELF_PART_OFFSET_32BIT_VALUE) };

    std::vector<ElfPart> l_expectedElfParts;

    expectElfPartContainersAreEqual(l_targetElfParts, l_expectedElfParts);
}

TEST_F(ElfPartAssemblerProgramHeadersAssemblingX32TestSuite, shouldAssembleAllCorrectElfPartsFrom32BitProgramHeadersContainer)
{
    Elf32_Phdr l_firstProgramHeader {
        .p_type = FIRST_PROGRAM_HEADER_TYPE_VALUE,
        .p_offset = FIRST_PROGRAM_HEADER_OFFSET_VALUE,
        .p_vaddr = FIRST_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE,
        .p_paddr = FIRST_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE,
        .p_filesz = FIRST_PROGRAM_HEADER_FILESIZE_VALUE,
        .p_memsz = FIRST_PROGRAM_HEADER_MEMSIZE_VALUE,
        .p_flags = FIRST_PROGRAM_HEADER_FLAGS_VALUE,
        .p_align = FIRST_PROGRAM_HEADER_ALIGN_VALUE
    };

    Elf32_Phdr l_secondProgramHeader {
        .p_type = SECOND_PROGRAM_HEADER_TYPE_VALUE,
        .p_offset = SECOND_PROGRAM_HEADER_OFFSET_VALUE,
        .p_vaddr = SECOND_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE,
        .p_paddr = SECOND_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE,
        .p_filesz = SECOND_PROGRAM_HEADER_FILESIZE_VALUE,
        .p_memsz = SECOND_PROGRAM_HEADER_MEMSIZE_VALUE,
        .p_flags = SECOND_PROGRAM_HEADER_FLAGS_VALUE,
        .p_align = SECOND_PROGRAM_HEADER_ALIGN_VALUE
    };

    Elf32_Phdr l_thirdProgramHeader {
        .p_type = THIRD_PROGRAM_HEADER_TYPE_VALUE,
        .p_offset = THIRD_PROGRAM_HEADER_OFFSET_VALUE,
        .p_vaddr = THIRD_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE,
        .p_paddr = THIRD_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE,
        .p_filesz = THIRD_PROGRAM_HEADER_FILESIZE_VALUE,
        .p_memsz = THIRD_PROGRAM_HEADER_MEMSIZE_VALUE,
        .p_flags = THIRD_PROGRAM_HEADER_FLAGS_VALUE,
        .p_align = THIRD_PROGRAM_HEADER_ALIGN_VALUE
    };

    std::vector<Elf32_Phdr> l_programHeaders {l_firstProgramHeader, l_secondProgramHeader, l_thirdProgramHeader};

    ElfPartAssembler l_elfPartAssembler {};
    const auto& l_targetElfParts { l_elfPartAssembler.assembleElfPartsFromProgramHeaders(l_programHeaders, PROGRAM_HEADER_ELF_PART_OFFSET_32BIT_VALUE) };

    std::vector<ElfPart> l_expectedElfParts;

    expectElfPartContainersAreEqual(l_targetElfParts, generate32BitElfParts());
}

struct ElfPartAssemblerProgramHeadersAssemblingX64TestSuite : public ElfPartAssemblingTestSuite
{};

TEST_F(ElfPartAssemblerProgramHeadersAssemblingX64TestSuite, shouldNotAssembleAnyCorrectElfPartFrom64BitEmptyProgramHeadersContainer)
{
    ElfPartAssembler l_elfPartAssembler {};

    std::vector<Elf64_Phdr> l_programHeaders;

    const auto& l_targetElfParts { l_elfPartAssembler.assembleElfPartsFromProgramHeaders(l_programHeaders, PROGRAM_HEADER_ELF_PART_OFFSET_64BIT_VALUE) };

    std::vector<ElfPart> l_expectedElfParts;

    expectElfPartContainersAreEqual(l_targetElfParts, l_expectedElfParts);
}

TEST_F(ElfPartAssemblerProgramHeadersAssemblingX64TestSuite, shouldAssembleAllCorrectElfPartsFrom64BitProgramHeadersContainer)
{
    Elf64_Phdr l_firstProgramHeader {
        .p_type = FIRST_PROGRAM_HEADER_TYPE_VALUE,
        .p_flags = FIRST_PROGRAM_HEADER_FLAGS_VALUE,
        .p_offset = FIRST_PROGRAM_HEADER_OFFSET_VALUE,
        .p_vaddr = FIRST_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE,
        .p_paddr = FIRST_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE,
        .p_filesz = FIRST_PROGRAM_HEADER_FILESIZE_VALUE,
        .p_memsz = FIRST_PROGRAM_HEADER_MEMSIZE_VALUE,
        .p_align = FIRST_PROGRAM_HEADER_ALIGN_VALUE
    };

    Elf64_Phdr l_secondProgramHeader {
        .p_type = SECOND_PROGRAM_HEADER_TYPE_VALUE,
        .p_flags = SECOND_PROGRAM_HEADER_FLAGS_VALUE,
        .p_offset = SECOND_PROGRAM_HEADER_OFFSET_VALUE,
        .p_vaddr = SECOND_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE,
        .p_paddr = SECOND_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE,
        .p_filesz = SECOND_PROGRAM_HEADER_FILESIZE_VALUE,
        .p_memsz = SECOND_PROGRAM_HEADER_MEMSIZE_VALUE,
        .p_align = SECOND_PROGRAM_HEADER_ALIGN_VALUE
    };

    Elf64_Phdr l_thirdProgramHeader {
        .p_type = THIRD_PROGRAM_HEADER_TYPE_VALUE,
        .p_flags = THIRD_PROGRAM_HEADER_FLAGS_VALUE,
        .p_offset = THIRD_PROGRAM_HEADER_OFFSET_VALUE,
        .p_vaddr = THIRD_PROGRAM_HEADER_VIRTUAL_ADDRESS_VALUE,
        .p_paddr = THIRD_PROGRAM_HEADER_PHYSICAL_ADDRESS_VALUE,
        .p_filesz = THIRD_PROGRAM_HEADER_FILESIZE_VALUE,
        .p_memsz = THIRD_PROGRAM_HEADER_MEMSIZE_VALUE,
        .p_align = THIRD_PROGRAM_HEADER_ALIGN_VALUE
    };

    std::vector<Elf64_Phdr> l_programHeaders {l_firstProgramHeader, l_secondProgramHeader, l_thirdProgramHeader};

    ElfPartAssembler l_elfPartAssembler {};
    const auto& l_targetElfParts { l_elfPartAssembler.assembleElfPartsFromProgramHeaders(l_programHeaders, PROGRAM_HEADER_ELF_PART_OFFSET_64BIT_VALUE) };

    std::vector<ElfPart> l_expectedElfParts;

    expectElfPartContainersAreEqual(l_targetElfParts, generate64BitElfParts());
}
